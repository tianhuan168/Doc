&emsp;&emsp;前些日子去瓜子二手车去面试，整个过程轻松愉快。
跟面试官从架构到底层的各种讨论，以及各种假想情况下的架构设计。

&emsp;&emsp;其中谈到了一个dubbo的负载均衡的策略，
凭着记忆，列出了四种策略，详细的说明了随机策略（默认的）的实现原理，并稍微带过了轮询/最少活跃/一致性哈希的策略。

&emsp;&emsp;引申到了***一致性哈希***的算法，然后引申到了redis的一致性hash是怎么实现的，如果有3台服务器，key均匀的分布在3台服务器组成的hash轮盘上，
如果有一台机器挂掉或者新增一台服务器以后，是怎么实现快速准确定位到key上的。

&emsp;&emsp;当时脑袋一片空白，平时很少去关注集群的东西，面试前也突击了部分redis的面试点，但是这个一致性hash还是真的没有去看过，
凭着自己平时的见解，简单给出了部分方案：

1.  **主从复制，一个服务器挂掉，去从salver上去获取，就近原则**
1.  **伪装服务器一直存在，平稳迁移key去剩余的其他服务器（没理论经验）**

回来后查了一部分资料，特意收集起来，方便以后查阅

----

我们在使用Redis的时候，为了保证Redis的高可用，提高Redis的读写性能，最简单的方式我们会做主从复制，组成Master-Master或者Master-Slave的形式，或者搭建Redis集群，进行数据的读写分离，类似于数据库的主从复制和读写分离。如下所示：

![image](https://img-blog.csdn.net/20180313185756947?watermark/2/text/Ly9ibG9nLmNzZG4ubmV0L3UwMTA4NzA1MTg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)


**redis、memcache**等是怎么实现集群负载均衡的呢？都是通过一致性hash算法实现节点调度的。
讲一致性hash算法前，先简述一下求余hash算法：
~~~
hash(key)%N  // N代表服务器个数 
~~~
- 一个缓存服务器宕机了，这样所有映射到这台服务器的对象都会失效，我们需要把属于该服务器中的缓存移除，这时候缓存服务器是 N-1 台，映射公式变成了 hash(object)%(N-1) ；
- 由于QPS升高，我们需要添加多一台服务器，这时候服务器是 N+1 台，映射公式变成了 hash(object)%(N+1) 。

1 和 2 的改变都会出现所有服务器需要进行数据迁移。
